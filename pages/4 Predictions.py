from joblib import load
import pandas as pd
import streamlit as st
import datetime
from utils import import_data as imda
import plotly.express as px
from statsmodels.tsa.statespace.sarimax import SARIMAX
from statsmodels.tsa.arima.model import ARIMA
from matplotlib import pyplot as plt


# CONFIG DE LA PAGE --> AVEC FAVICON
st.set_page_config(page_title="Projet Energie - pr√©dictions", page_icon="üåü", layout="wide")

 # Dictionnaire des meilleurs mod√®les par r√©gion
meilleurs_modeles = {
    "11 - Ile de France": ('SARIMAX', (0, 1, 2), (1, 2, 2, 12)),
    "24 - Centre-Val de Loire": ('SARIMAX', (0, 1, 2), (1, 2, 2, 12)),
    "27 - Bourgogne-Franche-Comt√©": ('SARIMAX', (0, 1, 2), (1, 2, 2, 12)),
    "28 - Normandie": ('SARIMAX', (0, 1, 2), (1, 2, 2, 12)),
    "32 - Hauts-de-France": ('SARIMAX', (0, 1, 2), (1, 2, 2, 12)),
    "44 - Grand Est": ('SARIMAX', (0, 1, 2), (1, 2, 2, 12)),
    "52 - Pays de la Loire": ('SARIMAX', (0, 1, 2), (1, 2, 2, 12)),
    "53 - Bretagne": ('SARIMAX', (0, 1, 2), (1, 2, 2, 12)),
    "75 - Nouvelle-Aquitaine": ('SARIMAX', (0, 1, 2), (1, 2, 2, 12)),
    "76 - Occitanie": ('ARIMA', (1, 0, 1), (2, 0, 0, 12)),
    "84 - Auvergne-Rh√¥ne-Alpes": ('SARIMAX', (0, 1, 2), (1, 2, 2, 12)),
    "93 - Provence-Alpes-C√¥te d Azur": ('SARIMAX', (0, 1, 2), (1, 2, 2, 12)),
   
}


def creer_modele(data, modele_info):
    type_modele, order, seasonal_order = modele_info
    if type_modele == 'SARIMAX':
        model = SARIMAX(data, order=order, seasonal_order=seasonal_order)
    elif type_modele == 'ARIMA':
        model = ARIMA(data, order=order, seasonal_order=seasonal_order)
    results = model.fit()
    return results

# Chargement des DataFrames
df_energie = imda.get_df_energie()  # Charge df_energie depuis CSV
df_group = imda.get_df_group(df_energie.copy())  # Charge df_group depuis CSV


# # Cr√©er un dictionnaire pour stocker les DataFrames par r√©gion
df_par_region = {}
for region, df_region in df_group.groupby("Code INSEE r√©gion"):
    if df_region.index.duplicated().any():
        df_region = df_region[~df_region.index.duplicated(keep='first')]
    df_region = df_region.asfreq('MS')
    df_par_region[region] = df_region


# Listes des codes INSEE et des noms de r√©gions
codes_insee = ['11', '24','27','28','32','44','52','53','75', '76','84','93']
noms_regions = ['Ile de France', 'Centre-Val de Loire', 'Bourgogne-Franche-Comt√©','Normandie','Hauts-de-France','Grand Est','Pays de la Loire','Bretagne','Nouvelle-Aquitaine','Occitanie','Auvergne-Rh√¥ne-Alpes','Provence-Alpes-C√¥te d Azur']

# Concat√©ner le code INSEE et le nom de la r√©gion
regions_concatenees = [f"{code} - {nom}" for code, nom in zip(codes_insee, noms_regions)]

# Chargement du mod√®le
model_national = load('model_national.pkl')

# SIDEBAR A GAUCHE CLASSIQUE
st.sidebar.title("Predictions")
pages = ["Prediction Nationale", "Prediction R√©gionale"]
page = st.sidebar.radio("Aller vers", pages)


# Chargement des DataFrames
conso = imda.get_conso(df_energie)  # Charge conso depuis CSV

# Appel de la fonction pour appliquer les styles
imda.apply_styles()


# Titre principal avec grande taille de police, align√© √† gauche
st.markdown('<p class="big-font">üìà Pr√©dictions</p>', unsafe_allow_html=True)



# SWITCH SUR LA PAGE DE PREDICTION
if page == "Prediction Nationale":
    st.markdown('<p class="medium-font"><b>Pr√©dictions de la consommation √©lectrique nationale</b></p>', unsafe_allow_html=True)

    # Cr√©ation de colonnes pour les entr√©es de dates
    col1, col2 = st.columns(2)
 
    # Saisie des dates de d√©but et de fin
    d = col1.date_input('Date d√©but', datetime.date.today())
    f = col2.date_input('Date fin', datetime.date(datetime.datetime.now().year + 1, 9, 1))

    # Faire la pr√©diction en fonction des dates saisies
    if d >= datetime.date(2021, 1, 1):
        prediction = model_national.get_prediction(start=d, end=f)
    else:
        prediction = model_national.get_prediction(start=pd.to_datetime('2021-01-01'), end=f)

    predicted_consumption = prediction.predicted_mean
    pred_ci = prediction.conf_int()

   

    # Cr√©ation du DataFrame pour les pr√©dictions
    pred = pd.DataFrame({
        'PERIODE': predicted_consumption.index,
        'Consommation (MW)': predicted_consumption.values
    })

    start_date = '2021-01-01'

    # Visualisation
    plt.figure(figsize=(15, 8))
    if d < datetime.date(2024, 9, 1):
        filtered_conso = conso[(conso.index > pd.to_datetime(d))]
        plt.plot(filtered_conso, label='Donn√©es r√©elles')
    plt.plot(predicted_consumption, color="orange", label='Pr√©dictions')
    plt.fill_between(pred_ci.index, pred_ci.iloc[:, 0], pred_ci.iloc[:, 1], color='grey', alpha=0.2, label='Intervalle de confiance')
    if d <= datetime.date(2021, 1, 1):
        plt.axvline(x=pd.to_datetime(start_date), color='red', linestyle='--', label='Date de d√©but des pr√©dictions')
    plt.legend()
    plt.grid(True)
    plt.title(f'Pr√©dictions de la consommation √©lectrique (MW) nationale')
    st.pyplot(plt)

    predicted_consumption = predicted_consumption.to_frame()
    predicted_consumption = predicted_consumption.rename(columns = {'predicted_mean' : 'Consommation (MW)'})
    
    if d < datetime.date(2021, 1, 1):
        res = pd.concat([filtered_conso, predicted_consumption[predicted_consumption.index > pd.to_datetime('2024-09-01')]])
    else:
        res = predicted_consumption[predicted_consumption.index > pd.to_datetime('2024-09-01')]
         
    res = pd.concat([res, pred_ci], axis = 1)

    st.dataframe(res)

    
elif page == "Prediction R√©gionale":

    # Appel de la fonction pour appliquer les styles
    imda.apply_styles()

    # Texte d'introduction au choix du mod√®le 
    st.markdown('<p class="small-font">Pour d√©finir le choix du mod√®le au niveau r√©gional, nous avons test√© plusieurs solutions :</p>', unsafe_allow_html=True)

    # Choix des mod√®les avec liste √† puces
    st.markdown("""
    <li class="small-font">Exp√©rimentation du mod√®le SARIMAX, d√©fini au niveau national, appliqu√© aux donn√©es r√©gionales.</li>
    <li class="small-font">Approche statistique classique : on adapte un mod√®le √† l'ensemble du lot de donn√©es pour d√©terminer si param√®tres des variables sont significatifs ou non</li>
    <li class="small-font">Mise en place de l'apprentissage automatique pour optimiser les pr√©dictions, sans se pr√©occuper de la relation entre les variables.</li>
    </ul>
    """, unsafe_allow_html=True)

     # Conclusion sur le choix du mod√®le 
    st.markdown('<p class="small-font">Nous avons choisi le mod√®le qui offrait les meilleures performances en fonction des m√©triques MAE, MSE, RMSE, et R¬≤.</p>', unsafe_allow_html=True)


    # Interface Streamlit
    st.markdown('<p class="medium-font"><b>Pr√©dictions de la consommation √©lectrique par r√©gion</b></p>', unsafe_allow_html=True)

    # Cr√©ation de colonnes pour les entr√©es de dates
    col1, col2 = st.columns(2)

    # Saisie des dates de d√©but et de fin
    d = col1.date_input('Date d√©but', datetime.date.today())
    f = col2.date_input('Date fin', datetime.date(datetime.datetime.now().year + 1, 9, 1))

    # S√©lection de la r√©gion
    region_selection = st.selectbox('S√©lectionnez une r√©gion', regions_concatenees)

    # Afficher les pr√©dictions pour la r√©gion s√©lectionn√©e
    if region_selection:
        region_code = region_selection.split(' - ')[0]
        df_region = df_par_region[int(region_code)].drop(columns=['Code INSEE r√©gion'])
        modele_info = meilleurs_modeles.get(region_selection)
        
        model_regional = load(f'model_region_{region_code}.pkl')
        
        if modele_info:
            start_date = '2021-01-01'
            end_date = '2024-12-01'
            # Faire la pr√©diction en fonction des dates saisies
            if d >= datetime.date(2021, 1, 1):
                pred = model_regional.get_prediction(start=d, end=f)
            else:
                pred = model_regional.get_prediction(start=pd.to_datetime(start_date), end=f)
            pred_mean = pred.predicted_mean
            pred_ci = pred.conf_int()

            # Visualisation
            plt.figure(figsize=(15, 8))
            if d < datetime.date(2024, 9, 1):
                filtered_conso = df_region[(df_region.index > pd.to_datetime(d))]
                plt.plot(filtered_conso, label='Donn√©es r√©elles')
            plt.plot(pred_mean, color="orange", label='Pr√©dictions')
            plt.fill_between(pred_ci.index, pred_ci.iloc[:, 0], pred_ci.iloc[:, 1], color='grey', alpha=0.2, label='Intervalle de confiance')
            if d <= datetime.date(2021, 1, 1):
                plt.axvline(x=pd.to_datetime(start_date), color='red', linestyle='--', label='Date de d√©but des pr√©dictions')
            plt.legend()
            plt.grid(True)
            plt.title(f'Pr√©dictions de la consommation √©lectrique (MW) pour la r√©gion {region_selection}')
            st.pyplot(plt)
            
            predicted_consumption = pred_mean.to_frame()
            predicted_consumption = predicted_consumption.rename(columns = {'predicted_mean' : 'Consommation (MW)'})
            
            if d < datetime.date(2024, 9, 1):
                res = pd.concat([filtered_conso, predicted_consumption[predicted_consumption.index > pd.to_datetime('2024-09-01')]])

            else:
                res = predicted_consumption[predicted_consumption.index > pd.to_datetime('2024-09-01')]
            res = pd.concat([res, pred_ci], axis = 1)
            
            st.dataframe(res)


        else:
            st.write("Aucun mod√®le trouv√© pour cette r√©gion.")


